### 메모리 동적 할당을 통한 단일 링크드 리스트 구현 ##

입력, 삭제, 확인 이 구현되어 있습니다.

메모리 동적 할당을 통한 단일 링크드 리스트 구현
연결 리스트의 시작점인 **head** 노드는 처음 생성된 뒤 운동장의 역할을 합니다.
즉, 리스트에서 데이터를 담는 실제 노드들은 힙 메모리에 고정되어 있는 방이고,
**head**는 이 방들을 쉽게 이야기하면 바라보는 출발점 역할을 하는 **하나의 운동장** 좌표일 뿐입니다.
노드를 삽입하거나 삭제할 때 함수 안에서 생성되는 **cur, prev, target, updateNode** 같은 포인터들은
각각 이 운동장을 출발점으로 삼아 주소값을 들고 뛰는 사람들로 비유할 수 있습니다.
그래서 각 사람 즉 포인터들이 들어올 때 뛰어줄 **레일**을 늘려주고 하나의 운동장을 공유하는 셈입니다.
이 포인터들은 함수 안에서만 존재하며, 함수가 끝나면 사라집니다.
같은 **출발점(head)**을 바라보고 시작할 수 있지만,
각자 독립적으로 리스트를 순회하며 위치를 확인하거나 연결을 업데이트합니다.
포인터가 이동해도 노드 자체는 움직이지 않고,
노드 안의 값을 바꾸면 그 노드를 바라보는 모든 포인터가 같은 변화를 관찰합니다.

**노드를 삽입할 때는, 각 노드가 자신의 앞과 뒤 방의 값을 비교하며, 값이 들어가야 할 위치를 찾으면,**
이전 노드(prev)와 순회 중인 노드(cur), 새로 생성된 노드(updateNode)를 사용해 적절히 연결을 수행합니다.
updateNode는 자기 자신만 기억하며,
cur은 한 칸 앞의 주소를 updateNode에게 전달하고,
prev는 새 노드를 이어야 할 위치를 알고 있어서, prev->next를 updateNode로 연결하고, updateNode->next를 cur로 연결합니다.

**삭제는 삽입과 반대로, 노드를 비교하며 위치를 찾는 방식으로 진행됩니다.**
**cur, prev, target 포인터**를 사용하여 리스트를 순회하며 삭제할 값을 찾고,
찾은 노드를 target으로 설정한 뒤, cur이 알고 있는 다음 노드 주소를 target에 연결하여 리스트 흐름을 유지합니다.
마지막으로 target 노드를 free하여 메모리에서 제거하고, prev->next가 target의 다음 노드를 가리키도록 업데이트합니다.

즉, 이 구현의 핵심은 노드를 직접 움직이는 것이 아니라, 포인터를 재배치하여 리스트의 연결을 유지하는 것이며,
head는 리스트의 출발점으로서 모든 포인터가 공유하는 시작 위치 역할을 하고,
함수에서 생성되는 포인터들은 각자 독립적으로 이동하며 연결과 탐색을 수행합니다.
노드 자체는 힙에 고정되어 있고, 노드 안의 값을 바꾸면 이를 바라보는 모든 포인터가 같은 변화를 관찰합니다.